## Software Development Skills for Research Computing

- Learn to apply some basic doftware development skills and tools to your code
- Make your research computing more robust and reproducible
- Discover some frameworks and methods that can help you write better code
- Point you towards resources

## Agenda

| Start time | End time | Duration | Content |
|---|---|---|---|
| **10:00** | **10:50** | **50 min** | **Intro presentation** |
| 10:50 | 11:00 | _10 min_ | _Short break_ |
| **11:00** | **12:00** | **60 min** | **Version control and project organisation** |
| 12:00 | 13:00 | _60 min_ | _Lunch_ |
| **13:00** | **13:50** | **50 min** | **Testing and linting code** |
| 13:50 | 14:00 | _10 min_ | _Short break_ |
| **14:00** | **14:45** | **45 min** | **Documentation and automated workflows** |
| 14:45 | 15:00 | _15 min_ | _Short break_ |
| **15:00** | **15:45** | **45 min** | **Packaging and releases** |
| **15:45** | **16:00** | **15 min** | **Questions, wrap-up** |

## Why apply software dev principles to your coding?

An example from my research: Electron Microprobe Analysis 

```{mermaid}
flowchart LR
  subgraph lab[1. Lab analysis of samples]
    direction TB
    A[Primary Standards: known comp. - P1] --> 
    B(Samples: unknown comp.) --> 
    C[Primary Standards again: known comp. - P2]
  end
  lab -..-> END[2. Instrument validation after data collection]
```

- Bracket samples with standards of known composition (published and trusted standards)


## Why apply software dev principles to your coding?

```{mermaid}
flowchart LR
  subgraph inst[2. Instrument validation after data collection]
    direction LR
    D[/Do P1 and P2<br>match each other<br>within error?/]-->|Yes| F
    D -->|No| E
    E(Instrument drift)
    F[/Do P1 and P2 match<br>published values<br> within error?/]
    F -->|No| G
    G(Calibration issue)
  end
  START[1. Lab analysis of samples] -.-> inst
  F -->|Yes| pos
  E --> neg
  G --> neg
  neg(fa:fa-ban Results not valid)
  pos(Results may be valid)
  pos --> posnext[Test scientific<br>validity of results]
  neg -.-> negnext[Check instrument settings<br>Rerun analyses]
```

- Compare standards to each other to see results are consistent over time
- Compare standards to their published compositions
   - Well-established allowable error

## Why apply software dev principles to your coding?

```{mermaid}
flowchart LR
  subgraph lab[1. Lab analysis of samples]
    direction TB
    A[Primary Standards: known comp. - P1] --> 
    B(Samples: unknown comp.) --> 
    C[Primary Standards again: known comp. - P2]
  end
  subgraph inst[2. Instrument validation after data collection]
    direction LR
    D[/Do P1 and P2<br>match each other<br>within error?/]-->|Yes| F
    D -->|No| E
    E(Instrument drift)
    F[/Do P1 and P2 match<br>published values<br> within error?/]
    F -->|No| G
    G(Calibration issue)
  end
  lab ---> inst
  F -->|Yes| pos
  E --> neg
  G --> neg
  neg(fa:fa-ban Results not valid)
  pos(Results may be valid)
  pos --> posnext[Test scientific<br>validity of results]
  neg -.-> negnext[Check instrument settings<br>Rerun analyses]
```

- Without the above documented steps, my results would not be publishable or considered in any way robust
- How do we implement a similar workflow for computational research?
  - We treat code as a laboratory instrument!

# Anything worth doing, is worth doing well


# Anything worth doing well, is worth doing poorly at first


# Using git

##

### git workflow

```{mermaid}
gitGraph
   commit id: "First commit"
   commit id: "Add README.md"
```

##

### git workflow

```{mermaid}
gitGraph
   commit id: "First commit"
   commit id: "Add README.md"
   branch first-feature
   checkout first-feature
   commit id: "Adding code"
```

##

### git workflow

```{mermaid}
gitGraph
   commit id: "First commit"
   commit id: "Add README.md"
   branch first-feature
   checkout first-feature
   commit id: "Adding code"
   commit
   commit
   checkout main
   merge first-feature id: "Tests pass"
```

##

### git workflow

```{mermaid}
gitGraph
   commit id: "First commit"
   commit id: "Add README.md"
   branch first-feature
   checkout first-feature
   commit id: "Adding code"
   commit
   commit
   checkout main
   merge first-feature id: "Tests pass"
   branch new-feature
   checkout new-feature
   commit
```

##

### git workflow

```{mermaid}
gitGraph
   commit id: "First commit"
   commit id: "Add README.md"
   branch first-feature
   checkout first-feature
   commit id: "Adding code"
   commit
   commit
   checkout main
   merge first-feature id: "Tests pass"
   branch new-feature
   checkout new-feature
   commit
   commit id: "Tests fail!" type:REVERSE
```

##

### git workflow

```{mermaid}
gitGraph
   commit id: "First commit"
   commit id: "Add README.md"
   branch first-feature
   checkout first-feature
   commit id: "Adding code"
   commit
   commit
   checkout main
   merge first-feature id: "Tests pass"
   branch new-feature
   checkout new-feature
   commit
   commit id: "Tests fail!" type:REVERSE
   checkout main
   branch new-feature-02
   commit
   commit
```

##

### git workflow

```{mermaid}
gitGraph
   commit id: "First commit"
   commit id: "Add README.md"
   branch first-feature
   checkout first-feature
   commit id: "Adding code"
   commit
   commit
   checkout main
   merge first-feature id: "Tests pass"
   branch new-feature
   checkout new-feature
   commit
   commit id: "Tests fail!" type:REVERSE
   checkout main
   branch new-feature-02
   commit
   commit
   checkout main
   merge new-feature-02 id: "Tests pass still"
```

## 