---
format: 
  revealjs:
    navigation-mode: linear
    controls-layout: bottom-right
    controls: true
    footer: "[Research IT Website]({{< var rc.website >}}) | [Research IT Query]({{< var rc.servicedesk >}}) | [Courses Material]({{< var rc.material >}})"
code: HPC 0
name: Introduction to Linux for HPC at Leeds
---


## Presentation set up
- If using Teams share browser window then activate presenter mode from the menu.
  - This should open a new browser window in presenter mode...


{{< include _title.qmd >}}


<!--
{{< include _team.qmd >}}
-->


## Contact Details and Key Links {visibility="hidden"}
- ARC Website: {{< var rc.website >}}
- ARC Documentation: {{< var rc.documentation >}}
- General queries: {{< var rc.servicedesk >}}


## Training {visibility="hidden"}
![](assets/img/hpc0/training.png)


## ARC/HPC Training Portfolio {visibility="hidden"}
{{< var rc.training >}}
![](assets/img/hpc0/portfolio.png)


## Introduction {.smaller}
- Purpose of today
  - Gain experience
  - Build confidence
  - Prepare for HPC1
  - Get feedback from you about the training

::: {.notes}
- Course leader and staff introductions.
- If a hackpad is set up, ask participants to introduce themselves on it.
- Let everyone know they are welcome to:
  - Interrupt to ask for things to be clarified/repeated.
  - Ask questions.
  - Ask for help.
- If using Teams, then we can use the chat.
:::


## Syllabus {.smaller}
<!--
This should match what is in:
https://github.com/ARCLeeds/arcleeds.github.io/tree/master/_data/training_courses.yml
https://github.com/ARCTraining/rc-lesson-plans/blob/main/hpc0/hpc0-lesson-plan.md
-->
- Logging in
- Entering commands
- Finding out about commands
- File system navigation
- Commands to create, copy, move and delete files and directories
- Home directory contents
- File permissions
- Using commands to find, explore and filter data
- Wildcards
- Shell scripting basics

::: {.notes}
Outline of what we will attempt to cover in <3 hours with breaks.
Aim for 25 minutes sessions with 5 minute breaks.
:::


## Logging in {.smaller}
- [ARC Documentation >> Login]({{< var rc.login >}})
- How you login depends on your:
  - Host Operating System
    - From OSx or Linux: Use a terminal program
    - From Windows: Use MobaXTerm
  - Connection
    - On campus
      - Wireless is like 'off campus'
    - Off campus
      - But connected to the [University VPN](https://it.leeds.ac.uk/it?id=kb_article&sysparm_article=KB0014410) is like 'on campus'

::: {.notes}
- MobaXTerm is software that you should be able to download, install and run without a problem
- The University Virtual Private Network (VPN) is a type of secure network connection, enabling your computer to access the University network when working remotely. 
:::


## Logging in demo {.smaller}
::: {.notes}
- Demo login from OSx/Linux
- Demo login from Windows
:::


## Logging in exercise {.smaller}
- Please login.

::: {.notes}
- Check who is logged in
  - In a classroom post it notes could be used to signal
  - Online using Teams, an emoji poll can be used
- Help anyone struggling
- Those that cannot login can still follow along for a bit...
:::


## The shell and interface {.smaller}
- You login to a ('bash') shell and your Home directory
- The shell is a terminal emulator program that can execute other programs in response to text commands.
  - There is a prompt where textual commands can be entered.
  - Textual messages sent to the standard output are displayed by the prompt.
- As you login, your bash set up is finalised by reading some files in your Home directory.

::: {.notes}
- We will enter some commands shortly.
- After learning a bit about the file system.
:::


## What is BASH? {.smaller} {visibility="hidden"}
![](assets/img/hpc0/bash.png)


## What is a shell? {.smaller}
![](assets/img/hpc0/shell.png)

::: {.notes}
- Human users interface with the system via the shell.
- The shell communicates with the kernel that communicates with computer hardware and provides access the file system.
:::


## Filesystem basics {.smaller}
![](assets/img/hpc0/filesystem.png)

::: {.notes}
- The image shows a simplified filesystem.
  - We will look at what the actual file system looks like shortly...
- A Windows 'Folder' is like a Linux 'Directory':
  - A thing that can hold files and sub-folders/sub-directories.
- Directories are arranged in a heirarchy.
  - The top directory is the root directory.
- Each user has a Home Directory:
  - Where they login to.
  - Where their profile is stored.
:::


## Forward-slash / and back-slash \ {.smaller}
![](assets/img/hpc0/slash.png)

::: {.notes}
- The file path separator in Linux is /
- The file path separator in Windows is \
:::


## Absolute path {.smaller}
![](assets/img/hpc0/filesystem-absolute.png)

::: {.notes}
- The root directory is `/`.
- Linux does not have drive letters like Windows.
:::


## Relative path {.smaller}
![](assets/img/hpc0/filesystem-relative.png)

::: {.notes}
- `..` takes you up a level in the directory heirarchy
:::


## The default prompt {.smaller}
- Upon login, you should see a prompt that looks like the following:
```{.bash code-line-numbers=false}
[user@host ~]$
```
- Only:
  - '`user`' is your username
  - '`host`'
    - starts '`login1.`' or '`login2.`'
    - and ends '`arc3`' or '`arc4`'
- The '`~`' (tilda) in the prompt indicates that you are in your home directory.
- The '`$`' symbol is the end of the prompt and is where commands can be typed and entered

::: {.notes}
- You are always in a directory:
  - the working directory
  - By default this is where things are created or read from...
- Users can modify the prompt look and feel
  - Showing how to do that would be a distraction!
:::


## First commands {.smaller}
\
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`pwd`</td>
    <td>Print the current working directory</td>
  </tr>
  <tr>
    <td>`man`</td>
    <td>Load the manual</td>
  </tr>
  <tr>
    <td>`ls`</td>
    <td>List the contents of a directory</td>
  </tr>
  <tr>
    <td>`mkdir`</td>
    <td>Make a new directory</td>
  </tr>
  <tr>
    <td>`cd`</td>
    <td>Change directory</td>
  </tr>
</table>

::: {.notes}
- These are safe commands - they don't change anything.
- We will look at these in turn...
:::


## `pwd` {.smaller}
- A command to print the working directory.
```{.bash code-line-numbers=false}
[user@host ~]$ pwd
/home/homeXX/user
```
- When you run this the output will be slightly different:
  - '`XX`' should be a number like '`01`' or '`02`'
  - '`user`' should be your username

::: {.notes}
- Run from the user Home directory this reports the absolute path to it.
:::


## `pwd` demo {.smaller}
::: {.notes}
- Do a quick demo.
- If using Teams, then remember to share the right browser window when switching to share the slides.
  - The presenter mode slides will have opened in a different window.
:::


## `pwd` exercise {.smaller}
- Type '`pwd`' at the prompt by typing the letters, then press the `<return>` or `<enter>` key.
```{.bash code-line-numbers=false}
[user@host ~]$ pwd
/home/homeXX/user
```
- To print help about the `pwd` command enter:
```{.bash code-line-numbers=false}
pwd --help
```
- The result should look like:
```{.bash code-line-numbers=false}
[user@host ~]$ pwd -- help
pwd: pwd [-LP]
    Print the name of the current working directory.
    
    Options:
      -L	print the value of $PWD if it names the current working
    		directory
      -P	print the physical directory, without any symbolic links
    
    By default, `pwd' behaves as if `-L' were specified.
    
    Exit Status:
    Returns 0 unless an invalid option is given or the current directory
    cannot be read.
```


## `--help` and `man` {.smaller}
- `--help` is a command option that prints help about using that command.
- `man` is a command to bring up the manual.
- For help using `man`: press the h-key `<h>`.
- To quit the help about `man` or the man page: press `<q>`.
- To page through a man page: press `<space_bar>`.


## `--help` and `man` demo {.smaller}
::: {.notes}
- Demo
```{.bash code-line-numbers=false}
pwd --help
```
```{.bash code-line-numbers=false}
man pwd
```
:::


## `--help` and `man` exercise {.smaller}
- Enter:
```{.bash code-line-numbers=false}
man man
```
- For help using `man`: press the h-key `<h>`.
- To quit the help about `man` or any man page: press `<q>`.
- To page through a man page: press `<space_bar>`.
- Enter:
```{.bash code-line-numbers=false}
man pwd
```
- Enter:
```{.bash code-line-numbers=false}
man ls
```

::: {.notes}
- Encourage participants to try this for themsleves
- Pause for an emoji pll or similar.
:::


## `ls` 1/3 {.smaller}
- A command to list the contents of a directory.
- With seemingly nothing in a directory `ls` will print nothing.
- Files and directories starting with '`.`' are hidden by default.
- There are many options for `ls`
  - The `-a` option will list all the contents of a directory.
  - The `-l` option will list each item line by line with added details.
  - The `-H` option will report sizes in a more human readable format.
- Options can be listed in any order or combined...
- Entering '`ls -al`' or '`ls -la`' or '`ls -a -l`' or '`ls -l -a`' are equivallent.


## `ls` 2/3 {.smaller}
- Entering '`ls -al`' should usually result in something like shown below:
```{.bash code-line-numbers=false}
[user@host ~]$ ls -al
total 8
drwx------     2 user group   4096 MMM DD hh:mm .
drwxr-xr-x     3 root root    4096 MMM DD hh:mm ..
...
```
- The `...` may be many more lines of output.
- The first line is different to the others.
  - The number after total is a complicated metric that we can ignore for now...
- The last part of other output lines is the name as would be obtained using `ls -a`
  - '`.`' is the directory listed and '`..`' is the parent of that directory.
- Please don't worry about the other details for now...

::: {.notes}
- Permissions and other details listed are explained later...
:::


## `ls` 3/3 {.smaller}
- An '`ls -al`' in your home directory:
  - Should result in more output.
    - Details will look a bit different.
      - For instance, '`MMM`' should be three letters representing the month a file was created e.g. '`Jun`'.
  - Will reveal hidden but important files and directories...


## `ls` exercise {.smaller}
- Enter:
```{.bash code-line-numbers=false}
ls /
```
- The output lists what is in the Root directory.
- Enter:
```{.bash code-line-numbers=false}
ls ~
```
- The output lists everything that is in your home directory that is not hidden.
  - For new users, this should be nothing!
- Enter:
```{.bash code-line-numbers=false}
ls -al ~
```
- The output lists everything in your Home directory.


## Home directory hidden files and folders {.smaller}
- `.bash_history`
  - A log of commands that you have entered.
- `.bash_profile`
  - Defines your user settings for a login shell.
- `.bashrc`
  - Defines your user settings for a subshell.
- You may have other files and folders and more may get added as you use commands and applications.
- It is important to know these exist so as not to accidentally delete them.
- Only modify them carefully if at all!

::: {.notes}
- By carefully, this means by creating a backup copy before trying things.
:::


## `mkdir` 1/2 {.smaller}
- A command to create a directory.
- The following is for creating a directory named '`test`':
```{.bash code-line-numbers=false}
mkdir test
```
- Attempting to create a directory that already exists prints a warning.
```{.bash code-line-numbers=false}
[user@host ~]$ mkdir test
mkdir: cannot create directory ‘test’: File exists
```


## `mkdir` 2/2 {.smaller}
- The '`-p`' option allows for creating parent directories.
- The following creates the directory '`test2`' and in this the directory '`test3`'.
```{.bash code-line-numbers=false}
mkdir -p test2/test3
```
- To create a directory, you must have permission to write to the directory in which it is being created.
- Without write permissions a warning is printed, for example:
```{.bash code-line-numbers=false}
[user@host ~]$ mkdir /test
mkdir: cannot create directory ‘/test’: Permission denied
```


## `cd` {.smaller}
- A command to change directory.
```{.bash code-line-numbers=false}
[user@host ~]$ cd test
[user@host test]$ cd ~
[user@host ~]$ cd test
[user@host test]$ cd
[user@host ~]$ 
```
- Notice that the prompt changes.
- Without read permission you cannot change into a directory and a warning is printed:
```{.bash code-line-numbers=false}
[user@host ~]$ cd /root
-bash: cd: /root: Permission denied
```
- To return to your home directory use:
  - `cd` with no arguments or `cd ~`

::: {.notes}
- An appropriate relative path or the definitive absolute path can also be used to return to the user home directory.
:::


## `ls`, `mkdir` and `cd` demo {.smaller}


## `ls`, `mkdir` and `cd` exercise {.smaller}
- Use `ls`, `mkdir` and `cd` in your home directory.
- Check if there is a directory with your user name in `/nobackup/` and if not create it.


## Check point 1 {.smaller}
- You can only list or change into directories you have permission to read.
- Any questions?

::: {.notes}
- Is it time for a break?
:::


## Time savers 1/2 {.smaller}
- `<up>` and `<down>` arrow keys will load previously entered commands into the prompt.
- The control key `<Ctrl>` can be used in combination with other keys to do things:
  - `<Ctrl>` and `<c>` will cancel
    - This can terminate a running command or cancel/clear what is at the prompt.
  - At the prompt:
    - `<Ctrl>` and `<a>` will move the cursor to the start of what is at the prompt
    - `<Ctrl>` and `<e>` will move the cursor to the end of what is at the prompt
    - `<Ctrl>` and `<r>` will do a reverse search through the history of commands entered at the prompt which can then be edited or entered.

::: {.notes}
- An overview of the hidden files and directories is given later...
:::


## Time savers 2/2 {.smaller}
- The prompt cursor does not have to be at the end of what is written at the prompt to submit what is there to the interpreter (run it).
- The tab key `<Tab>` can be used to help autocomplete file paths.
  - Press `<Tab>` repeatedly two or three times to reveal optional paths.
    - This can make your computer output an audible 'beep'!
- Copy and paste using the mouse:
  - Highlight by left-click-hold and drag mouse.
  - Copy with right click then select copy option.
  - Paste with right click and select paste option
  - Or paste highlighted text using third mouse button.

::: {.notes}
- `<ctrl> + <c>` copies in Windows, but cancels in Linux!
:::


## Time savers demo {.smaller}


## Time savers exercise {.smaller}
- Use `<up>` and `<down>` arrow keys to load previously entered commands into the prompt.
- Use `<Ctrl>` and `<a>`, and `<Ctrl>` and `<e>` to move the cursor between the start and end of what is at the prompt.
- Use `<Ctrl>` and `<c>` to cancel.
- Use `<Ctrl>` and `<r>` to reverse search through the history of commands, and select one to edit or run.
- Use copy and paste to paste a command at the prompt.


## More commands {.smaller}
\
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`mv`</td>
    <td>Move a file or directory (can be used to rename)</td>
  </tr>
  <tr>
    <td>`cp`</td>
    <td>Copy a file or directory - using the `-r` option</td>
  </tr>
  <tr>
    <td>`touch`</td>
    <td>Access or create a file or directory.</td>
  </tr>
  <tr>
    <td>`rmdir`</td>
    <td>Remove (delete) a directory</td>
  </tr>
  <tr>
    <td>`rm`</td>
    <td>Remove (delete) a file or a directory - using the `-r` option</td>
  </tr>
</table>
\

::: {.notes}
- Perhaps warn users to take more care with these!
:::


## `mv` {.smaller}
- A command to move a file or directory (can be used to rename)
- The following would rename the file/directory '`test`' to '`test_renamed`'
```{.bash code-line-numbers=false}
mv test test_renamed
```

## `cp` {.smaller}
- A command to copy a file or directory
- If '`test`' is a file the following would make a copy named '`test_copy`':
```{.bash code-line-numbers=false}
cp test test_copy
```
- If '`test`' is a directory a warning would be printed:
```{.bash code-line-numbers=false}
[user@host ~]$ cp test test_copy
cp: omitting directory 'test'
```
- The '`-r`' option can copy a directory:
```{.bash code-line-numbers=false}
cp -r test test_copy
```


## `touch`, `>`, `>>` {.smaller}
- `touch` is a command that touches will either:
  - Create an empty file, or
  - Update file access and modification times to the current time.
- the symbol '`>`' can be used to direct the standard output to a file.
  - This will overwrite any existing file.
- The following would direct the output of `ls` to a file named '`ls.out`' 
```{.bash code-line-numbers=false}
ls > ls.out
```
- '`>>`' can be used in place of '`>`' to append to rather than overwrite the file.

::: {.notes}
- Maybe point out:
  - Multiple processes writing to the same file simultaneously can make a mess!
:::


## `rmdir` {.smaller}
- A command to remove (delete) a directory.
```{.bash code-line-numbers=false}
rmdir test
```
- It will only remove the directory if it is empty.
- If the directory is not empty, there will be a warning and the directory is not deleted.
```{.bash code-line-numbers=false}
[user@host ~]$ rmdir test
rmdir: failed to remove 'test': Directory not empty
```
- If the user does not have permission to delete the directory, a warning is printed.
```{.bash code-line-numbers=false}
[user@host ~]$ rmdir /root
rmdir: failed to remove '/root': Permission denied
```


## `rm` {.smaller}
- A command to remove (delete) files and directories.
- The following will remove a file called '`test`':
```{.bash code-line-numbers=false}
rm test
```
- To delete a directory and all contents the '`-r`' option can be used.
- The '`-i`' option allows for interactivity so the user can choose what to delete.
- The '`-f`' option forces.
- Take care with `rm`, especially combined with '`-r`' and '`-f`' options.

::: {.notes}
- Take care especially using wildcards, as it is all too easy to delete everything!
:::


## `mv`, `cp`, `rmdir`, `rm`, `touch`, `>`, `>>` demo {.smaller} {visibility="hidden"}
::: {.notes}
- Offer a demo?
:::

## `mv`, `cp`, `rmdir`, `rm`, `touch`, `>`, `>>` exercise {.smaller}
- Create some directories and files as follows:
```{.bash code-line-numbers=false}
mkdir -P test0/test01
mkdir test0/test02
touch test0/test01/test_file
```
- Copy '`test0/test01`' into '`test0/test03`'
- Move '`test0/test02`' into '`test0/test04`'
- Delete '`test0/test03`'
- Direct the output of '`ls`' into '`ls.out`'
- Append the output of '`ls -al`' into '`ls.out`'
- Next we will be using `cat` and `less` to look at the contents of '`ls.out`'...
  - So if you are waiting then look into using these commands...


## Check point 2 {.smaller}
- Any questions?

::: {.notes}
- Is it time for a break?
:::


## Yet more commands {.smaller}
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`cat`</td>
    <td>Concatenate and print.</td>
  </tr>
  <tr>
    <td>`less`</td>
    <td>Open into a paginated reader view</td>
  </tr>
  <tr>
    <td>`sort`</td>
    <td>Sort lines</td>
  </tr>
  <tr>
    <td>`cut`</td>
    <td>Cut lines based on a given character</td>
  </tr>
  <tr>
    <td>`head`</td>
    <td>Print the first lines of a file (default 10)</td>
  </tr>
  <tr>
    <td>`tail`</td>
    <td>Print the last lines of a file (default 10)</td>
  </tr>
  <tr>
    <td>`wc`</td>
    <td>Print newline, word, and byte counts for each FILE, and a total line if
more than one FILE is specified. A word is a non-zero-length sequence of characters delimited by white space.</td>
  </tr>
  <tr>
    <td>`grep`</td>
    <td>Filter lines</td>
  </tr>
  <tr>
    <td>`sed`</td>
    <td>Stream editor</td>
  </tr>
</table>


## git clone exercise {.smaller}
- Get a copy of some data using the following `git` command:
```{.bash code-line-numbers=false}
git clone https://github.com/ARCTraining/shell-training/
```
- git is a distributed version control system
- Change directory into the directory called 'shell-training'.
- List the directory contents.


## `cat`, `sort` and `cut` {.smaller}
- The `cat` command will concatenate and print to standard output.
  - This can be used to stream one thing after another.
- The `sort` command will sort lines (by default alphabetically).
- The `cut` command will cut lines based on a given character.
- Commands that create an output stream can have the output piped into another command that can process the stream using the symbol '`|`'. 
  - For example two files '`test`' and '`test2`' can be concatenated, sorted alphabetically and piped into head as follows: 
```{.bash code-line-numbers=false}
cat test test2 | sort | head
```


## `cat`, `sort` and `cut` demo {visibility="hidden"}
::: {.notes}
- Offer a demo?
:::

## `cat`, `sort` and `cut` exercise {.smaller}

::: {.panel-tabset}

### Problem
- Combine `cat`, `cut`, and `sort` to print out the Latin names from the file `IOM-animals/birds.txt` in alphabetical order.
- Save the output to a new file.
Hint: `cut -d ',' -f 2` will split lines around the comma and yield the second field.

### Solution
```{.bash code-line-numbers=false}
cat birds.txt | sort | cut -d ',' -f 2 > sorted-birds.txt
```
\
\
- Another option to achieve the same is to use `awk` instead of `cut`:
```{.bash code-line-numbers=false}
cat birds.txt | sort | awk '{FS=","}{print $2}' > sorted-birds.txt
```
- `awk` is a scripting language used for manipulating data and generating reports.
  - It supports variables, numeric functions, string functions, and logical operators.
  - It allows for setting field seperators of multiple characters, whereas `cut` is restricted to a single character field seperator. 
- The '`{FS=","}`' part of the `awk` command sets the field seperator to a comma, to set as a space followed by a comma use '`{FS=" ,"}`'

:::


## `head` and `tail` {.smaller}
- The `head` command prints the first lines of a file.
- The `tail` command prints the last lines of a file.
- The default number of lines is 10.
 - This can be changed with the '`-n`' option


## `head` and `tail` exercise {.smaller}

::: {.panel-tabset}

### Problem
- List all the lines in the files in `IOM-animals` directory alphabetically and find the `50th` item.

### Solution
- Use `head` to get the first 50 lines and `pipe it` to `tail` to get the last one:
```{.bash code-line-numbers=false}
sort *.txt | head -n 50 | tail -n 1
```
\
\
- Another option is to use the `sed` command instead of `head` and `tail`:
```{.bash code-line-numbers=false}
sort *.txt | sed -n 50p
```
:::


## `sed` 1/2 {.smaller}
- A program command tool for stream editing.
- `sed` reads an input stream and produces an output stream.
  - Internally it has a pattern space and a hold buffer.
  - Data is read from the input stream until the next newline character and placed into the pattern space.
  - Operations can be performed on the data in the pattern space.
  - Data can be exchanged between the pattern space and the hold buffer.
  - Once all specified operations have been performed, the pattern space is ouput and a newline characer is added at the end.


## `sed` 2/2 {.smaller}
- A simple `sed` program:
```{.bash code-line-numbers=false}
sed 's/foo/bar/'
```
- This program replaces all instance of 'foo' with 'bar' on every line.
- Beware of `sed` as it can modify files.


## `grep`
- A command to print all lines containing or not containing a string of characters.
- The following will stream out all input lines containing 'foo':
```{.bash code-line-numbers=false}
grep foo
```
- The following will stream out all input lines not containing 'foo':
```{.bash code-line-numbers=false}
grep -v foo
```

## `sed` and `grep` demo 
::: {.notes}
- Offer a demo?
:::

## data challenge exercise {.smaller}

::: {.panel-tabset}

### Problem
- `shell-training/data/` contains 300 data files, each of which should contain 100 values. One or more of these files are missing some data though...
- Use a series of commands connected by pipes to identify which files have missing data.
- Hints:
  - `wc -w` will tell you the number of values in a file
  - `sort -n` will sort numerically

### Solution
- Using `grep`:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | grep -v '100 values'
```
\
- Using `head`:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | head
```
\
\
- Alternatively `awk` could be used:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | awk '$1 != 100 {print $0}'
```
:::


## Permissions 1/4 {.smaller}
- File permissions can be identified using the `ls` command with the `-l` option.
- By default, the owner has read, write and execute permissions on a directory they create, and read and write (but not execute) permission on a file they create.
- By default, group and all have no permissions.
```{.bash code-line-numbers=false}
[user@host ~]$ mkdirs -p test0/test
[user@host ~]$ touch test0/test/test-file
[user@host ~]$ ls -la test0/test
drwx------ 2 <owner> <group> <size> <date> <time> .
drwx------ 3 <owner> <group> <size> <date> <time> ..
-rw------- 1 <owner> <group> <size> <date> <time> test-file
```


## Permissions 2/4 {.smaller}
- A schematic to help explain what `ls -l` shows:
```
-rw------- 1 <owner> <group> <size> <date> <time> test-file
     |     |    |       |       |      |      |
     |     |    |       |       |      |      +----> time last modified
     |     |    |       |       |      +-----------> date last modified
     |     |    |       |       +------------------> size in bytes
     |     |    |       +--------------------------> group assignment
     |     |    +----------------------------------> owner username
     |     +---------------------------------------> number of hard link
     +---------------------------------------------> type and permissions
```
- A schematic to help explain the type and permissions part:
```
-rw-------
| |  |  |
| |  |  +----> all user permissions (3 characters)
| |  +-------> group user permissions (3 characters)
| +----------> owner permissions (3 characters)
+------------> type (1 character)
```


## Permissions 3/4 {.smaller}
### Type and permissions examples
- ```drwxr-x---```
  - type: directory
  - owner permissions: read, write and execute
  - group user permissions: read and execute
  - all user permissions: none
- ```-rw-------```
  - type: file
  - owner permissions: read and write
  - group user permissions: none
  - all user permissions: none


## Permissions 4/4 {.smaller}
- Permissions may be changed using the `chmod` command.
- Specific permissions can be granted or removed or all permissions can be specified.
- The following would set permissions ```-rwx------``` to '`test0/test/test-file`':
```{.bash code-line-numbers=false}
chmod 700 test0/test/test-file
```
- Don't worry about remembering details of how to change permissions.
- Try to remember that there are 3 levels of permission:
  - user (owner), group and all
- Try to remember that there are 3 types of permission:
  - read, write and execute

::: {.notes}
- The following would add user (owner) execute permissions.
  - So if the file already had all other permissions as wanted this would work. 
```{.bash code-line-numbers=false}
chmod u+x test0/test/test-file
```
- octal value = read (4) + write (2) + execute (1)
- Later on we will set permissions on a file to execute it.
:::


## Groups {.smaller} {visibility="hidden"}
- System users belong to groups (at least one).
- A user can change the group assignment for a file or directory to other groups they belong to using the command `chgrp`.
- The command `groups` can be used to print out what groups there are, and what group a user is part of.
- This can be useful if you want to share files between those in a group on the system.


## Check point {.smaller}
- Any questons?

::: {.notes}
- Time for a break?
:::


## Variables {.smaller}
- Variables are defined and accessed as follows:
```{.bash code-line-numbers=false}
var=1
echo $var
```
- The variable `var` is set equal to the number `1`.
- `echo` is a command that will send what comes after it to standard out
- The value of the variable is accessed using the `$` symbol followed by the name of the variable.
- The command `printenv` will print all the variables.


## For loop 1/2 {.smaller}
```
- Example for loop with iterator syntax to print the numbers 1 to 5:
```{.bash code-line-numbers=false}
for ((i=1;i<=5;i=i+1)) do echo $i; done
```
- Example for loop with sequence syntax to print the numbers 1 to 5:
```{.bash code-line-numbers=false}
for i in {1..5}; do echo $i; done
```
- Example for loop with sequence syntax to print even numbers from 2 to 10:
```{.bash code-line-numbers=false}
for i in {2..10..2}; do echo $i; done
```
- Example for loop with iterator syntax to print a geometric series from 2 to 256:
```{.bash code-line-numbers=false}
for ((i=2;i<=265;i=i*2)) do echo $i; done
```


## For loop 2/2 {.smaller}
- Example for loop to loop through directory contents:
```{.bash code-line-numbers=false}
for f in *; do echo $f; done
```
- Where there is a '`;`' there can be a new line:
```{.bash code-line-numbers=false}
for f in *
 do echo $f
 done
```


## For loops exercise 1 {.smaller}

::: {.panel-tabset}

### Problem
- Use a for loop to create five directories called `calculation_?`, where `?` is a number. 

### Solution
- For loop with an iterator syntax
```{.bash code-line-numbers=false}
for ((i=1;i<6;i++))
do
mkdir calculation_$i
done
```
- '`i++`' is shorthand for '`i=i+1`'
- For loop with a sequence syntax
```{.bash code-line-numbers=false}
for i in {1..5}
do
mkdir calculation_$i
done
```

:::


## For loops exercise 2 {.smaller}

::: {.panel-tabset}

### Problem
- Use a for loop to create five directories, each one the parent of the next.

### Solution
```{.bash code-line-numbers=false}
for i in {1..5}; do
mkdir calculation_$i
cd calculation_$i
done
```

:::


## Wildcards {.smaller}
- There are 3 types of wildcard in Linux:
  - `*` can represent anything.
  - `?` can represent any single character.
  - `[]` can represent any single characters detailed in the square brackets.
- The following will list all files starting with a:
```{.bash code-line-numbers=false}
`ls a*`
```
- The following will list all files starting with `a` and ending `.txt` that have one character between these:
```{.bash code-line-numbers=false}
`ls a?.txt`
```
- The following will list all files starting with `a` and ending `.txt` that have any other string with a `0` or a `1` character between these:
```{.bash code-line-numbers=false}
`ls a[12].txt`
```


## Wildcards exercise {.smaller}

::: {.panel-tabset}

### Problem
- Print out the first line of each file in the `wildcards` directory.

### Solution

```{.bash code-line-numbers=false}
for f in *.txt
> do
> head -n 1 $f
> done
```

:::


## quiz {.smaller}

::: {.panel-tabset}

### Questions
1. If the following is run from the wildcards directory. What will be printed?
```{.bash code-line-numbers=false}
for f in *.txt
> do
> echo $f
> cat $f > new-file.txt
> done
```
2. What will the contents of `new-file.txt` be and why?

### Answers
1.
- The command will print the name of each `.txt` file.
- On each iteration the `echo` command prints a different file name.
2.
- The content of `new-file.txt` will be the same as `xyz.txt`
- On each iteration the contents of a different file are written to `new-file.txt`, overwriting whatever was written on the previous iteration
- This is because `>` overwrites the output of cat to `new-file.txt` for each element in the sequence.
- Using `>>` instead would result in each file's content being appended to the end of `new-file.txt`

:::


## Editing files {.smaller}
- There are three programs available on the system that can be used for text editing:
  - `nano`
  - `vi`
  - `emacs`
- If you are unfamiliar with any of these, we recommend you try `nano`.
- Care is needed if transferring scripts and data between Windows and Linux due to differences in line endings.
  - `dos2unix` and `unix2dos` may be helpful to get this right.

::: {.notes}
- Data/File transfer is covered in HPC1.
:::


## Shell Scripts {.smaller}
- These are simple text files.
  - By convention the filename ends `.sh`.
- The file should start with a 'shebang' line which tells the Linux system what command to run:
```{.bash code-line-numbers=false}
#!/bin/bash`
```
- After the 'shebang', simply enter all the commands for the script.
- Lines starting with '`#`' will be regarded as comments
  - Use these to make you script easier to understand.
- To run the script it must have executable permissions.
- A scripts saved as '`script.sh`' can be run using:
```{.bash code-line-numbers=false}
./script.sh
```


## Shell Scripts demo {.smaller}


## Shell Script exercise {.smaller}
- Create and run a shell script to print out the first line of each file in a directory. Test using the wildcards directory.
- Hints:
  - Use the `history` command to see the commands you executed.
  - You could pipe this into tail and direct it into a file and then use the `nano` - a text editor to modify this into a script.
  - Modify the file permissions so you can execute the file. 
  - To execute a script called '`script.sh`' issue the following command:
```{.bash code-line-numbers=false}
./script.sh
```

::: {.notes}
- Scripts you write that you commonly want to run can be put somehwere sensible and this can be added to your PATH.
- If there is more time, perhaps look at the `find` command.
:::


{{< include _end.qmd >}}
