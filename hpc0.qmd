---
format: 
  revealjs:
    navigation-mode: linear
    controls-layout: bottom-right
    controls: true
    footer: "[Research IT Website]({{< var rc.website >}}) | [Research IT Query]({{< var rc.servicedesk >}}) | [Courses Material]({{< var rc.material >}})"
code: HPC 0
name: Introduction to the Unix/Linux command line
---

{{< include _title.qmd >}}

{{< include _team.qmd >}}

## Contact Details and Key Links
- ARC Website: {{< var rc.website >}}
- ARC Documentation: {{< var rc.documentation >}}
  - [ARC Documentation Helpful Shell Commands]({{< var rc.commands >}})
- General queries: {{< var rc.servicedesk >}}


## Training
![](assets/img/hpc0/training.png)


## ARC/HPC Training Portfolio
{{< var rc.training >}}
![](assets/img/hpc0/portfolio.png)


## Purpose of today {.smaller}
- Introduce the command line
- Hands on experience and confidence building
- Learn about:
  - File system navigation
  - Creating, reading, updating and deleting files
  - Using command history
  - Permissions
  - Stream manipulation
    - Inspecting, editing and filtering
- Introduce shell scripting


## Introductions and Motivations
- Who are you and why are you here?


## Me {visibility="hidden"}
- Research Computing service
- Research Computing Consultant
- Everything from HPC to Data Science
- RSE Cloud Computing Fellow
- Research in Deep Learning: Neural networks for text summarisation


## What is BASH?
![](assets/img/hpc0/bash.png)


## What is a shell?
![](assets/img/hpc0/shell.png)


## Filesystem basics
![](assets/img/hpc0/filesystem.png)


## Forward slash / and backslash \
![](assets/img/hpc0/slash.png)


## Filesystem basics: absolute path
![](assets/img/hpc0/filesystem-absolute.png)


## Filesystem basics: relative path
![](assets/img/hpc0/filesystem-relative.png)


## Login from Linux/OSx demo


## Login from Windows demo
- Launch MobaXTerm...


## Login exercise {.smaller}
- [ARC Documentation Login]({{< var rc.login >}})
- Please login to ARC3 or ARC4.
```{.bash code-line-numbers=false}
ssh <username>@arc3.leeds.ac.uk
ssh <username>@arc4.leeds.ac.uk
```
- `<username>` is your university username.*
- We want everyone logged in now
  - You can still follow along if there are issues...


## The prompt {.smaller}
- Upon login, you should see a prompt that looks like the following:
```{.bash code-line-numbers=false}
[user@host ~]$
```
- Only:
  -'`user`' is your username
  - '`host`'
    - either starts '`login1.`' or '`login2.`'
      - (there are two login nodes for ARC3 and ARC4)
    - and is followed by the name of the resource '`arc3`' for ARC3 or '`arc4`' for ARC4
- Upon login you are in your user home directory represented by '`~`' (tilda) in the prompt.
- After the `$` symbol is where text based commands are entered...


## First (safe) commands {.smaller}
\
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`pwd`</td>
    <td>Print the current working directory</td>
  </tr>
  <tr>
    <td>`man`</td>
    <td>Load the manual</td>
  </tr>
  <tr>
    <td>`ls`</td>
    <td>List the contents of a directory</td>
  </tr>
  <tr>
    <td>`mkdir`</td>
    <td>Make a new directory</td>
  </tr>
  <tr>
    <td>`cd`</td>
    <td>Change directory</td>
  </tr>
</table>


## `pwd` {.smaller}
- A command to print the working directory.
```{.bash code-line-numbers=false}
[user@host ~]$ pwd
/home/homeXX/user
```
- When you run this the output will be slightly different:
  - '`XX`' should be a number like '`01`' or '`02`'
  - '`user`' should be your username


## `pwd` exercise {.smaller}
- Type '`pwd`' at the prompt by typing the letters, then press the `<return>` or `<enter>` key.
```{.bash code-line-numbers=false}
[user@host ~]$ pwd
/home/homeXX/user
```
- To print help about the `pwd` command enter:
```{.bash code-line-numbers=false}
pwd --help
```
- The result should look like:
```{.bash code-line-numbers=false}
[user@host ~]$ pwd -- help
pwd: pwd [-LP]
    Print the name of the current working directory.
    
    Options:
      -L	print the value of $PWD if it names the current working
    		directory
      -P	print the physical directory, without any symbolic links
    
    By default, `pwd' behaves as if `-L' were specified.
    
    Exit Status:
    Returns 0 unless an invalid option is given or the current directory
    cannot be read.
```


## `--help` and `man` {.smaller}
- `--help` is a command option that can be used to get help on using a command.
- `man` is a command to bring up the manual.
- For help using `man`: press the h-key `<h>`.
- To quit the help about `man` or the man page: press `<q>`.
- To page through a man page: press `<space_bar>`.


## `man` demo


## `man` exercise {.smaller}
- Enter:
```{.bash code-line-numbers=false}
man man
```
- For help using `man`: press the h-key `<h>`.
- To quit the help about `man` or any man page: press `<q>`.
- To page through a man page: press `<space_bar>`.
- Enter:
```{.bash code-line-numbers=false}
man pwd
```
- Enter:
```{.bash code-line-numbers=false}
man ls
```


## `ls` 1/3 {.smaller}
- A command to list the contents of a directory.
- With seemingly nothing in a directory `ls` will print nothing.
- Files and directories starting with '`.`' are hidden by default.
- There are many options for `ls`
  - The `-a` option will list all the contents of a directory.
  - The `-l` option will list each item line by line with added details.
  - The `-H` option will report sizes in a more human readable format.
- Options can be listed in any order or combined...
- Entering '`ls -al`' or '`ls -la`' or '`ls -a -l`' or '`ls -l -a`' are equivallent.


## `ls` 2/3 {.smaller}
- Entering '`ls -al`' should usually result in something like shown below:
```{.bash code-line-numbers=false}
[user@host ~]$ ls -al
total 8
drwx------     2 user group   4096 MMM DD hh:mm .
drwxr-xr-x     3 root root    4096 MMM DD hh:mm ..
...
```
- The `...` may be many more lines of output.
- The first line is different to the others.
  - The number after total is a complicated metric that we can ignore for now...
- The last part of other output lines is the name as would be obtained using `ls -a`
  - '`.`' is the directory listed and '`..`' is the parent of that directory.
- Please don't worry about the other details for now...


## `ls` 3/3 {.smaller}
- An '`ls -al`' in your home directory:
  - Should result in many more lines of output.
  - The details will look a bit different.
    - For instance, '`MMM`' should be three letters representing the month a file was created e.g. '`Jun`'.
  - Will reveal hidden but important files and directories:
    - Let us not concern ourselves with these for now...


## `mkdir` {.smaller}
- A command to create a directory.
- The following is to create a directory named '`test`':
```{.bash code-line-numbers=false}
mkdir test
```
- Attempting to create a directory that already exists prints a warning.
```{.bash code-line-numbers=false}
[user@host ~]$ mkdir test
mkdir: cannot create directory ‘test’: File exists
```
- The '`-p`' option allows for creating parent directories.
- The following creates the directory '`test2`' and in this the directory '`test3`'.
```{.bash code-line-numbers=false}
mkdir -p test2/test3
```
- To create a directory, you must have permission to write to the directory in which it is being created.
- Without write permissions a warning is printed, for example:
```{.bash code-line-numbers=false}
[user@host ~]$ mkdir /test
mkdir: cannot create directory ‘/test’: Permission denied
```


## `cd` {.smaller}
- A command to change directory.
```{.bash code-line-numbers=false}
[user@host ~]$ cd test
[user@host test]$ cd ~
[user@host ~]$ cd test
[user@host test]$ cd
[user@host ~]$ 
```
- Notice that the prompt changes.
- Without read permission you cannot change into a directory and a warning is printed:
```{.bash code-line-numbers=false}
[user@host ~]$ cd /root
-bash: cd: /root: Permission denied
```
- And you remain where you are.
- To return to you home directory use `cd` with no arguments or `cd ~` or specify an appropriate relative path or the absolute path (as discerned earlier).


## `ls`, `mkdir` and `cd` demo {.smaller}


## `ls`, `mkdir` and `cd` exercise {.smaller}
- Explore using `ls`, `mkdir` and `cd` in your home directory.
- Check if there is a directory with your user name in `/nobackup/` and if not create it.


## Check point
- You will only be allowed to change into directories you have permission to read.
- Any questions?
- 10 minutes then back to consider some time savers and some more commands.


## Time savers 1/2 {.smaller}
- `<up>` and `<down>` arrow keys can load previously entered commands into the prompt.
- The control key `<Ctrl>` can be used in combination with other keys to do things:
  - `<Ctrl>` and `<c>` will cancel
    - This can terminate a running command or cancel/clear what is at the prompt.
  - At the prompt:
    - `<Ctrl>` and `<a>` will move the cursor to the start of what is at the prompt
    - `<Ctrl>` and `<e>` will move the cursor to the end of what is at the prompt
    - `<Ctrl>` and `<r>` will do a reverse search through the history of commands entered at the prompt and insert or execute a command.


## Time savers 2/2 {.smaller}
- The cursor does not have to be at the end of what is written at the prompt to submit what is there to the interpreter (run it).
- The tab key `<Tab>` can be used to help autocomplete file paths.
  - Press `<Tab>` repeatedly two or three times to reveal optional paths.
    - This can make your computer output an audible 'beep'!
- Copy and paste also should work...


## Time savers demo {.smaller}


## Time savers exercise {.smaller}
- Use `<up>` and `<down>` arrow keys to load previously entered commands into the prompt.
- Use `<Ctrl>` and `<a>`, and `<Ctrl>` and `<e>` to move the cursor between the start and end of what is at the prompt.
- Use `<Ctrl>` and `<c>` to cancel.
- Use `<Ctrl>` and `<r>` to reverse search through the history of commands, and select one to edit or run.
- Use copy and paste to paste a command at the prompt.


## Reflection {.smaller}
- There are other ways to save time at the command line and other `<Ctrl>` key combinations that you may want to learn in due course...
- Know how of commands and shortcuts and skill in using them comes with practise...
- The main keys to using commands:
  - Searching for potential solutions and finding out what commands are called.
  - Using `--help` and `man` to understand what commands do and how to use them.
  - Testing - especially if you are not sure what a command will do.


## More commands {.smaller}
\
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`mv`</td>
    <td>Move a file or directory (can be used to rename)</td>
  </tr>
  <tr>
    <td>`cp`</td>
    <td>Copy a file or directory - using the `-r` option</td>
  </tr>
  <tr>
    <td>`touch`</td>
    <td>Access or create a file or directory.</td>
  </tr>
  <tr>
    <td>`rmdir`</td>
    <td>Remove (delete) a directory</td>
  </tr>
  <tr>
    <td>`rm`</td>
    <td>Remove (delete) a file or a directory - using the `-r` option</td>
  </tr>
</table>
\
- Take more care with these!


## `mv` {.smaller}
- A command to move a file or directory (can be used to rename)
- The following would rename the file/directory '`test`' to '`test_renamed`'
```{.bash code-line-numbers=false}
mv test test_renamed
```
- A move can usually be reversed, but as things are moved around they are easier to lose!


## `cp` {.smaller}
- A command to copy a file or directory
- If '`test`' is a file the following would make a copy named '`test_copy`':
```{.bash code-line-numbers=false}
cp test test_copy
```
- If '`test`' is a directory a warning would be printed:
```{.bash code-line-numbers=false}
[user@host ~]$ cp test test_copy
cp: omitting directory 'test'
```
- The '`-r`' option can copy a directory:
```{.bash code-line-numbers=false}
cp -r test test_copy
```


## `touch`, `>`, `>>` {.smaller}
- `touch` is a command that touches a file or directory and can be used to create an empty file.
  - `touch` changes the recorded time an existing file or directory was last accessed.
- the symbol '`>`' can be used to direct the standard output to a file.
  - This will overwrite any existing file.
- The following would direct the output of `ls` to a file named '`ls.out`' 
```{.bash code-line-numbers=false}
ls > ls.out
```
- '`>>`' can be used in place of '`>`' to direct the standard output to a file appending to any content in that file.
- If there is more than one process writing to a file simultaneously, it might end up in a mess!


## `rmdir` {.smaller}
- A command to remove (delete) a directory.
```{.bash code-line-numbers=false}
rmdir test
```
- It will only remove the directory if it is empty.
- If the directory is not empty, there will be a warning and the directory is not deleted.
```{.bash code-line-numbers=false}
[user@host ~]$ rmdir test
rmdir: failed to remove 'test': Directory not empty
```
- If the user does not have permission to delete the directory, a warning is printed.
```{.bash code-line-numbers=false}
[user@host ~]$ rmdir /root
rmdir: failed to remove '/root': Permission denied
```


## `rm` {.smaller}
- A command to remove (delete) a file or directory.
- The following will remove a file called '`test`':
```{.bash code-line-numbers=false}
rm test
```
- To delete a directory and all contents the '`-r`' option can be used.
- The '`-i`' option allows for interactivity so the user can choose what to delete.
- The '`-f`' option forces.
- Take care with `rm`, especially combined with '`-r`' and '`-f`' options.


## `mv`, `cp`, `rmdir`, `rm`, `touch`, `>`, `>>` demo {.smaller} {visibility="hidden"}
- Offer a demo?


## `mv`, `cp`, `rmdir`, `rm`, `touch`, `>`, `>>` exercise {.smaller}
- Create come directories and files as follows:
```{.bash code-line-numbers=false}
mkdir -P test0/test01
mkdir test0/test02
touch test0/test01/test_file
```
- Copy '`test0/test01`' into '`test0/test03`'
- Move '`test0/test02`' into '`test0/test04`'
- Delete '`test0/test03`'
- Direct the output of '`ls`' into '`ls.out`'
- Append the output of '`ls -al`' into '`ls.out`'
- Next we will learn to use `cat` and `less` to look at the contents of `test_ls`...
  - So if you are waiting then look into using these commands...


## Feedback {.smaller}
- Any questions?
- Coming up...
  - Commands to process streams.


## Yet more commands {.smaller}
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`cat`</td>
    <td>Concatenate and print.</td>
  </tr>
  <tr>
    <td>`less`</td>
    <td>Open into a paginated reader view</td>
  </tr>
  <tr>
    <td>`sort`</td>
    <td>Sort lines</td>
  </tr>
  <tr>
    <td>`cut`</td>
    <td>Cut lines based on a given character</td>
  </tr>
  <tr>
    <td>`head`</td>
    <td>Print the first lines of a file (default 10)</td>
  </tr>
  <tr>
    <td>`tail`</td>
    <td>Print the last lines of a file (default 10)</td>
  </tr>
  <tr>
    <td>`wc`</td>
    <td>Print newline, word, and byte counts for each FILE, and a total line if
more than one FILE is specified. A word is a non-zero-length sequence of characters delimited by white space.</td>
  </tr>
  <tr>
    <td>`grep`</td>
    <td>Filter lines</td>
  </tr>
  <tr>
    <td>`sed`</td>
    <td>Stream editor</td>
  </tr>
</table>


## git clone exercise
- Get a copy of some data using the following `git` command:
```{.bash code-line-numbers=false}
git clone https://github.com/ARCTraining/shell-training/
```
- git is a distributed version control system
- Change directory into the directory called 'shell-training'.
- List the directory contents.


## `cat`, `sort` and `cut` {.smaller}
- The `cat` command will concatenate and print to standard output.
  - This can be used to stream one thing after another.
- The `sort` command will sort lines (by default alphabetically).
- The `cut` command will cut lines based on a given character.
- Commands that create an output stream can have the output piped into another command that can process the stream using the symbol '`|`'. 
  - For example two files '`test`' and '`test2`' can be concatenated, sorted alphabetically and piped into head as follows: 
```{.bash code-line-numbers=false}
cat test test2 | sort | head
```


## `cat`, `sort` and `cut` demo {visibility="hidden"}
- Offer a demo?


## `cat`, `sort` and `cut` exercise {.smaller}

::: {.panel-tabset}

### Problem
- Combine `cat`, `cut`, and `sort` to print out the Latin names from the file `IOM-animals/birds.txt` in alphabetical order.
- Save the output to a new file.
Hint: `cut -d ',' -f 2` will split lines around the comma and yield the second field.

### Solution
```{.bash code-line-numbers=false}
cat birds.txt | sort | cut -d ',' -f 2 > sorted-birds.txt
```
\
\
- Another option to achieve the same is to use `awk` instead of `cut`:
```{.bash code-line-numbers=false}
cat birds.txt | sort | awk '{FS=","}{print $2}' > sorted-birds.txt
```
- `awk` is a scripting language used for manipulating data and generating reports.
  - It supports variables, numeric functions, string functions, and logical operators.
  - It allows for setting field seperators of multiple characters, whereas `cut` is restricted to a single character field seperator. 
- The '`{FS=","}`' part of the `awk` command sets the field seperator to a comma, to set as a space followed by a comma use '`{FS=" ,"}`'

:::


## `head` and `tail` {.smaller}
- The `head` command prints the first lines of a file.
- The `tail` command prints the last lines of a file.
- The default number of lines is 10.
 - This can be changed with the '`-n`' option


## `head` and `tail` exercise {.smaller}

::: {.panel-tabset}

### Problem
- List all the lines in the files in `IOM-animals` directory alphabetically and find the `50th` item.

### Solution
- Use `head` to get the first 50 lines and `pipe it` to `tail` to get the last one:
```{.bash code-line-numbers=false}
sort *.txt | head -n 50 | tail -n 1
```
\
\
- Another option is to use the `sed` command instead of `head` and `tail`:
```{.bash code-line-numbers=false}
sort *.txt | sed -n 50p
```
:::


## `sed` 1/2 {.smaller}
- A program command tool for stream editing.
- `sed` reads an input stream and produces an output stream.
  - Internally it has a pattern space and a hold buffer.
  - Data is read from the input stream until the next newline character and placed into the pattern space.
  - Operations can be performed on the data in the pattern space.
  - Data can be exchanged between the pattern space and the hold buffer.
  - Once all specified operations have been performed, the pattern space is ouput and a newline characer is added at the end.


## `sed` 2/2 {.smaller}
- A simple `sed` program:
```{.bash code-line-numbers=false}
sed 's/foo/bar/'
```
- This program replaces all instance of 'foo' with 'bar' on every line.
- Beware of `sed` as it can modify files.


## `grep`
- A command to print all lines containing or not containing a string of characters.
- The following will stream out all input lines containing 'foo':
```{.bash code-line-numbers=false}
grep foo
```
- The following will stream out all input lines not containing 'foo':
```{.bash code-line-numbers=false}
grep -v foo
```

## `sed` and `grep` demo {visibility="hidden"}
- Offer a demo?


## data challenge exercise {.smaller}

::: {.panel-tabset}

### Problem
- `shell-training/data/` contains 300 data files, each of which should contain 100 values. One or more of these files are missing some data though...
- Use a series of commands connected by pipes to identify which files have missing data.
- Hints:
  - `wc -w` will tell you the number of values in a file
  - `sort -n` will sort numerically

### Solution
- Using `grep`:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | grep -v '100 values'
```
\
- Using `head`:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | head
```
\
\
- Alternatively `awk` could be used:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | awk '$1 != 100 {print $0}'
```
:::


## Permissions 1/4 {.smaller}
- File permissions can be identified using the `ls` command with the `-l` option.
- By default, the owner has read, write and execute permissions on a directory they create, and read and write (but not execute) permission on a file they create.
- By default, group and all have no permissions.
```{.bash code-line-numbers=false}
[user@host ~]$ mkdirs -p test0/test
[user@host ~]$ touch test0/test/test-file
[user@host ~]$ ls -la test0/test
drwx------ 2 <owner> <group> <size> <date> <time> .
drwx------ 3 <owner> <group> <size> <date> <time> ..
-rw------- 1 <owner> <group> <size> <date> <time> test-file
```


## Permissions 2/4 {.smaller}
- A schematic to help explain what `ls -l` shows:
```
-rw------- 1 <owner> <group> <size> <date> <time> test-file
     |     |    |       |       |      |      |
     |     |    |       |       |      |      +----> time last modified
     |     |    |       |       |      +-----------> date last modified
     |     |    |       |       +------------------> size in bytes
     |     |    |       +--------------------------> group assignment
     |     |    +----------------------------------> owner username
     |     +---------------------------------------> number of hard link
     +---------------------------------------------> type and permissions
```
- A schematic to help explain the type and permissions part:
```
-rw-------
| |  |  |
| |  |  +----> all user permissions (3 characters)
| |  +-------> group user permissions (3 characters)
| +----------> owner permissions (3 characters)
+------------> type (1 character)
```


## Permissions 3/4 {.smaller}
### Type and permissions examples
- ```drwxr-x---```
  - type: directory
  - owner permissions: read, write and execute
  - group user permissions: read and execute
  - all user permissions: none
- ```-rw-------```
  - type: file
  - owner permissions: read and write
  - group user permissions: none
  - all user permissions: none


## Permissions 4/4 {.smaller}
- Permissions may be changed using `chmod`.
- There are a couple of main ways to change permissions...
- The following will change the '`test0/test/test-file`' permissions so the user can execute it.
```{.bash code-line-numbers=false}
chmod u+rwx test0/test/test-file
```
- The same can be achieved using octal values:
```{.bash code-line-numbers=false}
chmod 700 test0/test/test-file
```
- Later on we will set permissions on a file so we can execute it.
- Don't worry about remembering any details of how to change permissions
- Try to remember that there are 3 levels of permission:
  - user, group and all
- Try to remember that there are 3 types of permission:
  - read, write and execute


## Groups {.smaller}
- System users belong to groups (at least one).
- A user can change the group assignment for a file or directory to other groups they belong to using the command `chgrp`.
- The command `groups` can be used to print out what groups there are, and what group a user is part of.
- This can be useful if you want to share files between those in a group on the system.


## Short break {.smaller}
- Return for the final part in 10 minutes...


## For loop with iterator {.smaller}
- Example for loop with iterator to print the numbers 1, 3 and 5:
```{.bash code-line-numbers=false}
for ((i=1;i<=5;i=i+2)) do echo $i; done
```
- The for loop initialises a variable `i`.
  - The first time around the loop `i=1`.
  - The loop continues unitl `i<=5` evaluates as false.
  - Each time around the loop `2` is added to `i`.
  - Within the loop `i` is refered to as `$i`.
- `echo` is a command that prints to the standard output.
- The for loop ends with `done`.
- The semi-colon symbol `;` is in place of a line break


## For loop with sequence {.smaller}
- `{1..5}` is the sequence 1, 2, 3, 4, 5
- `{1..5..2} is the sequence 1, 3, 5
- Example for loop with iterator to print the numbers 1, 3 and 5:
```{.bash code-line-numbers=false}
for i in {1..5..2}; do echo $i; done
```
- The sequence variable `i` starts at `1` and ends at `5` and steps by `2`.
- A sequence could be the items in a directory or other things.


## For loops exercise 1 {.smaller}

::: {.panel-tabset}

### Problem
- Use a for loop to create five directories called `calculation_?`, where `?` is a number. 

### Solution
- For loop with an iterator
```{.bash code-line-numbers=false}
for ((i=1;i<6;i++))
do
mkdir calculation_$i
done
```
- '`i++`' is shorthand for '`i=i+1`'
- For loop with a sequence
```{.bash code-line-numbers=false}
for i in {1..5}
do
mkdir calculation_$i
done
```

:::


## For loops exercise 2 {.smaller}

::: {.panel-tabset}

### Problem
- Use a for loop to create five directories, each one the parent of the next.

### Solution
- Two commands are executed each time around the loop
  - A new directory is created
  - Then the working directory is changed to the new directory.
- For loop with an iterator
```{.bash code-line-numbers=false}
for ((i=1;i<6;i++))
do
mkdir calculation_$i
cd calculation_$i
done
```
- For loop with a sequence
```{.bash code-line-numbers=false}
for i in {1..5}; do
mkdir calculation_$i
cd calculation_$i
done
```

:::


## Wildcards {.smaller}
- There are 3 types of wilcard in Linux:
  - `*` can represent anything.
  - `?` can represent any single character.
  - `[]` can represent any single characters detailed in the square brackets.
- The following will list all files starting with a:
```{.bash code-line-numbers=false}
`ls a*`
```
- The following will list all files starting with `a` and ending `.txt` that have one character between these:
are two characters long:```{.bash code-line-numbers=false}
`ls a?.txt`
```
- The following will list all files starting with `a` and ending `.txt` that have any other string with a `0` or a `1` character between these:
```{.bash code-line-numbers=false}
`ls a[12].txt`
```


## Wildcards exercise {.smaller}

::: {.panel-tabset}

### Problem
- Print out the first line of each file in the `wildcards` directory.

### Solution

```{.bash code-line-numbers=false}
for f in *.txt
> do
> head -n 1 $f
> done
```

:::


## quiz {.smaller}

::: {.panel-tabset}

### Questions
1. If the following is run from the wildcards directory. What will be printed?
```{.bash code-line-numbers=false}
for f in *.txt
> do
> echo $f
> cat $f > new-file.txt
> done
```
2. What will the contents of `new-file.txt` be and why?

### Answers
1.
- The command will print the name of each `.txt` file.
- On each iteration the `echo` command prints a different file name.
2.
- The content of `new-file.txt` will be the same as `xyz.txt`
- On each iteration the contents of a different file are written to `new-file.txt`, overwriting whatever was written on the previous iteration
- This is because `>` overwrites the output of cat to `new-file.txt` for each element in the sequence.
- Using `>>` instead would result in each file's content being appended to the end of `new-file.txt`

:::


## Shell Scripts {.smaller}
- These are simple text files.
  - By convention the filename ends `.sh`.
- The file should start with a 'shebang' line which tells the Linux system what command to run:
```{.bash code-line-numbers=false}
#!/bin/bash`
```
- After the 'shebang', simply enter all the commands for the script.
- To run the script it must have executable permissions.


## Shell Script Exercise {.smaller}
- Create and run a shell script to print out the first line of each file in a directory. Test using the wildcards directory.
- Hints:
  - Use the `history` command to see the commands you executed.
  - You could pipe this into tail and direct it into a file and then use the `nano` - a text editor to modify this into a script.
  - Modify the file permissions so you can execute the file. 
  - To execute a script called '`script.sh`' issue the following command:
```{.bash code-line-numbers=false}
sh script.sh
```


{{< include _end.qmd >}}
