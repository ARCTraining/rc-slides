---
format:
  revealjs:
    navigation-mode: linear
    controls-layout: bottom-right
    controls: true
    footer: "[Research IT Website]({{< var rc.website >}}) | [Research IT Query]({{< var rc.servicedesk >}}) | [Courses Material]({{< var rc.material >}})"
code: HPC 0
name: Introduction to Linux for HPC
---


{{< include _donut.qmd >}}


{{< include _title.qmd >}}


{{< include _team.qmd >}}


## Training Themes
![](assets/img/hpc0/training.png)

::: {.notes}
- Read slide:
  - "We are developing and providing training in the following themes..."
:::


## Training Portfolio {visibility="hidden"}
- [Research Computing Website Training]({{< var rc.training >}})
![](assets/img/hpc0/portfolio.png)

::: {.notes}
- Skipping/hiding slide until we refactor what training we are doing and produce a new outline...
:::


## Aims {.smaller}
- Get aquainted.
- Gain experience and build confidence in using a Linux command line.
- Prepare for [HPC1: Introduction to High Performance Computing](https://arc.leeds.ac.uk/training/courses/hpc1/) (HPC1).
- Get feedback from you about the training.

::: {.notes}
- Read slide:
  - "Our training aims today are to..."
- "Please introduce yourself on the hackpad...":
  - If using Teams:
    - Share hackpad link in the chat.
    - Explain about using the chat.
    - Maybe conduct a poll:
      - Is everyone happy so far?
  - If not using Teams and in a classroom, then hopefully everyone can use the hackpad link from the course reminder email that should have been sent recieved recently...
- "Please interrupt if you are having difficulty hearing or following the presentation..."
  - "Please ask questions, or ask for things to be clarified or repeated..."
:::


## Syllabus {.smaller}
<!--
This should match what is in:
https://github.com/ARCLeeds/arcleeds.github.io/tree/master/_data/training_courses.yml
https://github.com/ARCTraining/rc-lesson-plans/blob/main/hpc0/hpc0-lesson-plan.md
-->
- Logging in
- Entering commands
- Finding out about commands
- File system navigation
- Commands to list, create, copy, move and delete files
- Hidden files
- Command history
- Control key combinations
- Editing files
- File permissions
- Commands to explore and filter data
- Wildcards
- Shell scripting basics

::: {.notes}
- "This slide shows the syllabus of what we plan to go through."
- "There is quite a lot to cover in 3 hours!"
- "We'll aim to have 5 or 10 minute breaks roughly every 30 minutes."
:::


## Logging in 1/3
- [ARC Documentation on Logging on]({{< var rc.login >}})
- How you login depends on your:
  - Host Operating System
  - Connection

::: {.notes}
- "The Website provides details about logging in"
- "How you login depends on your host Operating System and connection..."
:::


## Logging in 2/3
- Host Operating System:
  - OSX or Linux:
    - Use `terminal`
  - Windows:
    - Use `MobaXTerm`

::: {.notes}
- "The OSX `terminal` is already a Linux command line interface program:"
  - "Which may work slightly differently from the HPC Linux command line, but it will be broadly similar."
- "`MobaXTerm` is software that you should be able to download, install and run without needing help from systems administators."
  - "It provides a sort of bridge between your host Windows machine and other machines you connect with."
- Maybe conduct a poll:
  - "What host OS are you using?"
:::


## Logging in 3/3
- Connection
  - On campus
    - Wireless is like 'off campus'
  - Off campus
    - But connected to the [University VPN](https://it.leeds.ac.uk/it?id=kb_article&sysparm_article=KB0014410) is like 'on campus'

::: {.notes}
- Read slide:
  - "In terms of connection: On campus, but using wifi is like being 'off campus'..." 
- The University Virtual Private Network (VPN) is a type of secure network connection, enabling your computer to access the University network when working remotely.
- Maybe conduct a poll:
  - "What type of connection do you have?"
:::


## Logging in demos

::: {.notes}
- Demo login from OSx/Linux.
- Demo login from Windows.
:::


## Logging in exercise
- Please login.

::: {.notes}
- Maybe conduct a poll:
  - "Have you logged in?"
- Conduct/organise help if necessary...
  - Maybe susggest one-to-ones if there are helpers...
- Those that cannot login can still follow along for a bit...
- Is it time for a break 1?
:::


## The shell interface {.smaller}
- You login to a ('BASH') 'shell' and your 'Home Directory'
- A 'shell' is a terminal emulator program.
  - It is a window with a `prompt` at which textual commands are entered.
  - Standard Output (std.out) and Standard Error (std.err) streams get displayed in the window.
- During login, your set up is finalised by reading some files that reside in your Home Directory.

::: {.notes}
- Read slide:
  - "When you login, you login to..."
- "We will enter some commands and practice by doing shortly..."
  - "There are just a few more slides to go through first."
:::


## What is BASH? {.smaller}
- An example of what it looks like:
![](assets/img/hpc0/bash.png)

::: {.notes}
- `bash` is a particular type of shell.
:::


## What is a shell? 1/2 {.smaller}
![](assets/img/hpc0/shell.png)

::: {.notes}
- "Human users interface with the system via a shell."
- "A shell communicates with the kernel."
- "The kernel communicates with computer hardware and provides access the filesystem."
- "There are a variety of Linux kernels and shells."
:::


## What is a shell? 2/2 {.smaller}
- Shells have '`built-in`' commands:
  - When called from a shell, `built-in` commands execute directly in the shell, without invoking (calling) other programs.
- Shells call other programs by name, and these are found via the users '`PATH`' - a variable and ordered list of filesystem directories.
- "On HPC resources at Leeds:
   Additional Linux command utilities have been added and will be on your `PATH` for convenience.
  - Additional software has been installed.
    - Some of this is only available via a module system

::: {.notes}
- Read slide
  - "Shells have built-in commands..."
- "Details of the module system and how to use it are:"
  - "Not covered in this course, but in HPC1."
:::


## Filesystem basics {.smaller}
![](assets/img/hpc0/filesystem.png)

::: {.notes}
- "The image shows a simplified filesystem."
  - "We will look at what the actual file system looks like shortly..."
- "A Linux 'Directory' is like a Windows 'Folder':"
  - "A thing that can hold files and sub-folders/sub-directories."
- "Directories are arranged in a heirarchy."
  - "The top directory is the 'Root Directory'."
- "Each user has a 'Home Directory':"
  - "Where they login to."
  - "Where their profile is stored."
:::


## Forward-slash / and back-slash \ {.smaller}
![](assets/img/hpc0/slash.png)

::: {.notes}
- "The file path separator in Linux is the forward slash."
- "The file path separator in Windows is the back slash."
:::


## Absolute path {.smaller}
![](assets/img/hpc0/filesystem-absolute.png)

::: {.notes}
- "The slide shows an absolute file path."
- "The 'Root Directory' is referred to by a back slash."
  - "All absolute file paths start from the 'Root Directory'..." 
- Perhaps explain the file path further.
- "Linux does not have drive letters like Windows."
:::


## Relative path {.smaller}
![](assets/img/hpc0/filesystem-relative.png)

::: {.notes}
- "The slide shows a relative file path."
- "'`..`' refers to one level up in the directory heirarchy."
- Perhaps explain the file path further.
:::


## The default prompt {.smaller}
- Upon login, you should see a prompt that looks like the following:
```{.bash code-line-numbers=false}
[user@host ~]$
```
- Only:
  - '`user`' is your username
  - '`host`'
    - starts '`login1.`' or '`login2.`'
    - and ends '`arc3`' or '`arc4`'
- The '`~`' (tilda) in the prompt indicates that you are in your Home Directory.
- The '`$`' symbol is the end of the prompt and is where commands can be typed and entered.

::: {.notes}
- Read slide:
  - "Upon login..."
- "You are always in a directory:"
  - "The 'Working Directory'"
  - "By default this is where things are created or read from..."
- Is it time for a break 1?
- Users can modify the prompt and set different colours and languages...
:::


## First commands {.smaller}
\
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`pwd`</td>
    <td>Print the current working directory</td>
  </tr>
  <tr>
    <td>`man`</td>
    <td>Load the manual</td>
  </tr>
  <tr>
    <td>`ls`</td>
    <td>List the contents of a directory</td>
  </tr>
  <tr>
    <td>`mkdir`</td>
    <td>Make a new directory</td>
  </tr>
  <tr>
    <td>`cd`</td>
    <td>Change directory</td>
  </tr>
</table>

::: {.notes}
- "The table contains 'safe commands' - they don't change anything. So using them should not cause any damage..."
- "We will look at these in turn now..."
:::


## `pwd` {.smaller}
- A command to print the working directory.
```{.bash code-line-numbers=false}
[user@host ~]$ pwd
/home/homeXX/user
```
- When you run this the output will be slightly different:
  - '`XX`' should be a number like '`01`' or '`02`'
  - '`user`' should be your username

::: {.notes}
- Read slide:
  - "PWD is a command to print..."
- "Run from the user `Home directory` PWD reports the absolute path of the user `Home Directory`."
:::


## `pwd` demo {.smaller}

::: {.notes}
- Do a quick demo.
- If using Teams, then remember to share the right windows...
:::


## `pwd` exercise {.smaller}
- Type '`pwd`' at the prompt by typing the letters, then press the `<return>` or `<enter>` key.
```{.bash code-line-numbers=false}
[user@host ~]$ pwd
/home/homeXX/user
```
- To print help about the `pwd` command enter:
```{.bash code-line-numbers=false}
pwd --help
```
- The result should look like:
```{.bash code-line-numbers=false}
[user@host ~]$ pwd -- help
pwd: pwd [-LP]
    Print the name of the current working directory.
    
    Options:
      -L	print the value of $PWD if it names the current working
    		directory
      -P	print the physical directory, without any symbolic links
    
    By default, `pwd' behaves as if `-L' were specified.
    
    Exit Status:
    Returns 0 unless an invalid option is given or the current directory
    cannot be read.
```

::: {.notes}
- "Over to you to try this first exercise..."
:::


## `--help` and `man` {.smaller}
- `--help` is a command option that prints help about using that command.
- `man` is a command to bring up the manual.
- For help using `man`: press the h-key `<h>`.
- To quit the help about `man` or the man page: press `<q>`.
- To page through a man page: press `<space_bar>`.

::: {.notes}
- Read slide:
  - "Minus minus help..."
:::


## `--help` and `man` demo {.smaller}

::: {.notes}
- Demo
```{.bash code-line-numbers=false}
pwd --help
```
```{.bash code-line-numbers=false}
man pwd
```
```{.bash code-line-numbers=false}
man bash
```
```{.bash code-line-numbers=false}
man bash-builtins
```
:::


## `--help` and `man` exercise {.smaller}
- Enter:
```{.bash code-line-numbers=false}
man man
```
- For help using `man`: press the h-key `<h>`.
- To quit the help about `man` or any man page: press `<q>`.
- To page through a man page: press `<space_bar>`.
- Enter:
```{.bash code-line-numbers=false}
man pwd
```
- Enter:
```{.bash code-line-numbers=false}
man ls
```

::: {.notes}
- "Over to you to try this exercise..."
- Maybe conduct a poll:
  - "Are you ready to move on?"
- Check the time.
  - Is it time for a break 1?
:::


## `ls` 1/4 {.smaller}
- A command to list the contents of a directory.
- There are many options for `ls`
  - The `-a` option will list all the contents of a directory.
    - Files and directories starting with '`.`' are hidden by default.
  - The `-l` option will list each item line by line with added details.
  - The `-H` option will report sizes in a more human readable format.

::: {.notes}
- (Read slide)
  - "ls is a command..."
:::


## `ls` 2/4 {.smaller}
- Options can be listed in any order or combined - the following are equivallent:
```{.bash code-line-numbers=false}
ls -al
ls -la
ls -a -l
ls -l -a
```

::: {.notes}
- (Read slide)
  - "Options can be..."
:::


## `ls` 3/4 {.smaller}
```{.bash code-line-numbers=false}
[user@host ~]$ ls -al
total 8
drwx------     2 user group   4096 MMM DD hh:mm .
drwxr-xr-x     3 root root    4096 MMM DD hh:mm ..
...
```

::: {.notes}
- "Entering '`ls -al`' should usually result in something like what is shown."
- "The `...` may be many more lines of output depending on what was listed."
- "The first line is different to the others."
  - "The number after total is a complicated metric to do with how linked the thing being listed is."
- "The first part of other output lines detail permissions:"
  - "Permissions and other details listed are explained later..."
- "The last part of other output lines sre the names of the things listed."
  - "'`.`' would be the directory listed."
  - "'`..`' would be the parent of that directory."
- "Details will look a bit different for listing you do."
  - "For instance:"
    - "'`user`' should be your username."
    - "'`MMM`' would be three letters representing the month a file was created e.g. '`Jun`'."
:::


## `ls` 3/3 {.smaller}
- The following should result in many more lines of output.
```{.bash code-line-numbers=false}
[user@host ~]$ ls -al ~
```

::: {.notes}
- "Issuing an '`ls -al ~`' should list the details of everything in your Home Directory."
  - "This shold reveal any 'hidden' files and directories..."
:::


## `ls` exercise {.smaller}
- Enter:
```{.bash code-line-numbers=false}
ls /
```
- The output lists what is in the Root directory.
- Enter:
```{.bash code-line-numbers=false}
ls ~
```
- The output lists everything that is in your home directory that is not hidden.
  - For new users, this is nothing - not even a '`README.txt`'!
- Enter:
```{.bash code-line-numbers=false}
ls -al ~
```
- The output lists everything in your Home Directory.

::: {.notes}
- "Over to you to try this exercise..."
:::


## Home directory hidden files and folders {.smaller}
- `.bash_history`
  - A log of commands that you have entered.
- `.bash_profile`
  - Finalises your user login shell.
- `.bashrc`
  - Finalises your user subshell.

::: {.notes}
- (Read slide)
  - "The .bash_history file is a..."
- "You may have other hidden files and folders and more may get added as you use commands and applications."
- "It is important to know these exist so as not to accidentally delete them."
- "Only modify them carefully if at all!"
  - "This means by creating a backup copy before trying things."
:::


## `mkdir` 1/2 {.smaller}
- A command to create a directory.
- The following is for creating a directory named '`test`':
```{.bash code-line-numbers=false}
mkdir test
```
- Attempting to create a directory that already exists prints a warning.
```{.bash code-line-numbers=false}
[user@host ~]$ mkdir test
mkdir: cannot create directory ‘test’: File exists
```

::: {.notes}
- (Read slide)
  - "mkdir is a command to..."
:::


## `mkdir` 2/2 {.smaller}
- The '`-p`' option allows for creating parent directories.
- The following creates the directory '`test2`' and in this the directory '`test3`'.
```{.bash code-line-numbers=false}
mkdir -p test2/test3
```
- To create a directory, you must have permission to write to the directory in which it is being created.
- Without write permissions a warning is printed, for example:
```{.bash code-line-numbers=false}
[user@host ~]$ mkdir /test
mkdir: cannot create directory ‘/test’: Permission denied
```

::: {.notes}
- (Read slide)
  - "The mkdir -p option allows for creating parent directories...."
:::


## `cd` {.smaller}
- A command to change directory.
```{.bash code-line-numbers=false}
[user@host ~]$ cd test
[user@host test]$ cd ~
[user@host ~]$ cd test
[user@host test]$ cd
[user@host ~]$ 
```
- Notice that the prompt changes.
- Without read permission you cannot change into a directory and a warning is printed:
```{.bash code-line-numbers=false}
[user@host ~]$ cd /root
-bash: cd: /root: Permission denied
```
- To return to your home directory use:
  - `cd` with no arguments or `cd ~`

::: {.notes}
- (Read slide)
  - "cd is a command..."
:::


## `ls`, `mkdir` and `cd` demo {.smaller}

::: {.notes}
- Demo making, listing and moving into directories.
:::


## `ls`, `mkdir` and `cd` exercise {.smaller}
- Use `ls`, `mkdir` and `cd` in your home directory.
- Check if there is a directory with your user name in `/nobackup/` and if not create it.

::: {.notes}
- "Over to you for another quick exercise"
:::


## Check point 1 {.smaller}
- You can only list or change into directories you have permission to read.
- Any questions?

::: {.notes}
- Read slide:
  - "You can..."
- Is it time for a break?
:::


## Time savers 1/2 {.smaller}
- `<up>` and `<down>` arrow keys will load previously entered commands into the prompt.
- The control key `<Ctrl>` can be used in combination with other keys to do things:
  - `<Ctrl>` and `<c>` will cancel
    - This can terminate a running command or cancel/clear what is at the prompt.
  - At the prompt:
    - `<Ctrl>` and `<a>` will move the cursor to the start of what is at the prompt
    - `<Ctrl>` and `<e>` will move the cursor to the end of what is at the prompt
    - `<Ctrl>` and `<r>` will do a reverse search through the history of commands entered at the prompt which can then be edited or entered.

::: {.notes}
- An overview of the hidden files and directories is given later...
:::


## Time savers 2/2 {.smaller}
- The prompt cursor does not have to be at the end of what is written at the prompt to submit what is there to the interpreter (run it).
- The tab key `<Tab>` can be used to help autocomplete file paths.
  - Press `<Tab>` repeatedly two or three times to reveal optional paths.
    - This can make your computer output an audible 'beep'!
- Copy and paste using the mouse:
  - Highlight by left-click-hold and drag mouse.
  - Copy with right click then select copy option.
  - Paste with right click and select paste option
  - Or paste highlighted text using third mouse button.

::: {.notes}
- `<ctrl> + <c>` copies in Windows, but cancels in Linux!
:::


## Time savers demo {.smaller}


## Time savers exercise {.smaller}
- Use `<up>` and `<down>` arrow keys to load previously entered commands into the prompt.
- Use `<Ctrl>` and `<a>`, and `<Ctrl>` and `<e>` to move the cursor between the start and end of what is at the prompt.
- Use `<Ctrl>` and `<c>` to cancel.
- Use `<Ctrl>` and `<r>` to reverse search through the history of commands, and select one to edit or run.
- Use copy and paste to paste a command at the prompt.


## More commands {.smaller}
\
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`mv`</td>
    <td>Move a file or directory (can be used to rename)</td>
  </tr>
  <tr>
    <td>`cp`</td>
    <td>Copy a file or directory - using the `-r` option</td>
  </tr>
  <tr>
    <td>`touch`</td>
    <td>Access or create a file or directory.</td>
  </tr>
  <tr>
    <td>`rmdir`</td>
    <td>Remove (delete) a directory</td>
  </tr>
  <tr>
    <td>`rm`</td>
    <td>Remove (delete) a file or a directory - using the `-r` option</td>
  </tr>
</table>
\

::: {.notes}
- Perhaps warn users to take more care with these!
:::


## `mv` {.smaller}
- A command to move a file or directory (can be used to rename)
- The following would rename the file/directory '`test`' to '`test_renamed`'
```{.bash code-line-numbers=false}
mv test test_renamed
```

## `cp` {.smaller}
- A command to copy a file or directory
- If '`test`' is a file the following would make a copy named '`test_copy`':
```{.bash code-line-numbers=false}
cp test test_copy
```
- If '`test`' is a directory a warning would be printed:
```{.bash code-line-numbers=false}
[user@host ~]$ cp test test_copy
cp: omitting directory 'test'
```
- The '`-r`' option can copy a directory:
```{.bash code-line-numbers=false}
cp -r test test_copy
```


## `touch`, `>`, `>>` {.smaller}
- `touch` is a command that touches will either:
  - Create an empty file, or
  - Update file access and modification times to the current time.
- the symbol '`>`' can be used to direct the standard output to a file.
  - This will overwrite any existing file.
- The following would direct the output of `ls` to a file named '`ls.out`' 
```{.bash code-line-numbers=false}
ls > ls.out
```
- '`>>`' can be used in place of '`>`' to append to rather than overwrite the file.

::: {.notes}
- Maybe point out:
  - Multiple processes writing to the same file simultaneously can make a mess!
:::


## `rmdir` {.smaller}
- A command to remove (delete) a directory.
```{.bash code-line-numbers=false}
rmdir test
```
- It will only remove the directory if it is empty.
- If the directory is not empty, there will be a warning and the directory is not deleted.
```{.bash code-line-numbers=false}
[user@host ~]$ rmdir test
rmdir: failed to remove 'test': Directory not empty
```
- If the user does not have permission to delete the directory, a warning is printed.
```{.bash code-line-numbers=false}
[user@host ~]$ rmdir /root
rmdir: failed to remove '/root': Permission denied
```


## `rm` {.smaller}
- A command to remove (delete) files and directories.
- The following will remove a file called '`test`':
```{.bash code-line-numbers=false}
rm test
```
- To delete a directory and all contents the '`-r`' option can be used.
- The '`-i`' option allows for interactivity so the user can choose what to delete.
- The '`-f`' option forces.
- Take care with `rm`, especially combined with '`-r`' and '`-f`' options.

::: {.notes}
- Take care especially using wildcards, as it is all too easy to delete everything!
:::


## `mv`, `cp`, `rmdir`, `rm`, `touch`, `>`, `>>` demo {.smaller} {visibility="hidden"}
::: {.notes}
- Offer a demo?
:::

## `mv`, `cp`, `rmdir`, `rm`, `touch`, `>`, `>>` exercise {.smaller}
- Create some directories and files as follows:
```{.bash code-line-numbers=false}
mkdir -P test0/test01
mkdir test0/test02
touch test0/test01/test_file
```
- Copy '`test0/test01`' into '`test0/test03`'
- Move '`test0/test02`' into '`test0/test04`'
- Delete '`test0/test03`'
- Direct the output of '`ls`' into '`ls.out`'
- Append the output of '`ls -al`' into '`ls.out`'
- Next we will be using `cat` and `less` to look at the contents of '`ls.out`'...
  - So if you are waiting then look into using these commands...


## Check point 2 {.smaller}
- Any questions?

::: {.notes}
- Is it time for a break?
:::


## Yet more commands {.smaller}
\
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>`cat`</td>
    <td>Concatenate and print.</td>
  </tr>
  <tr>
    <td>`less`</td>
    <td>Open into a paginated reader view</td>
  </tr>
  <tr>
    <td>`sort`</td>
    <td>Sort lines</td>
  </tr>
  <tr>
    <td>`cut`</td>
    <td>Cut lines based on a given character</td>
  </tr>
  <tr>
    <td>`head`</td>
    <td>Print the first lines of a file (default 10)</td>
  </tr>
  <tr>
    <td>`tail`</td>
    <td>Print the last lines of a file (default 10)</td>
  </tr>
  <tr>
    <td>`wc`</td>
    <td>Print newline, word, and byte counts for each FILE, and a total line if more than one FILE is specified. A word is a non-zero-length sequence of characters delimited by white space.</td>
  </tr>
  <tr>
    <td>`grep`</td>
    <td>Filter lines</td>
  </tr>
  <tr>
    <td>`sed`</td>
    <td>Stream editor</td>
  </tr>
</table>


## git clone exercise {.smaller}
- Get a copy of some data using the following `git` command:
```{.bash code-line-numbers=false}
git clone https://github.com/ARCTraining/shell-training/
```
- git is a distributed version control system
- Change directory into the directory called 'shell-training'.
- List the directory contents.


## `cat`, `sort` and `cut` {.smaller}
- The `cat` command will concatenate and print to standard output.
  - This can be used to stream one thing after another.
- The `sort` command will sort lines (by default alphabetically).
- The `cut` command will cut lines based on a given character.
- Commands that create an output stream can have the output piped into another command that can process the stream using the symbol '`|`'. 
  - For example two files '`test`' and '`test2`' can be concatenated, sorted alphabetically and piped into head as follows: 
```{.bash code-line-numbers=false}
cat test test2 | sort | head
```


## `cat`, `sort` and `cut` demo {visibility="hidden"}
::: {.notes}
- Offer a demo?
:::

## `cat`, `sort` and `cut` exercise {.smaller}

::: {.panel-tabset}

### Problem
- Combine `cat`, `cut`, and `sort` to print out the Latin names from the file `IOM-animals/birds.txt` in alphabetical order.
- Save the output to a new file.
Hint: `cut -d ',' -f 2` will split lines around the comma and yield the second field.

### Solution
```{.bash code-line-numbers=false}
cat birds.txt | sort | cut -d ',' -f 2 > sorted-birds.txt
```
\
\
- Another option to achieve the same is to use `awk` instead of `cut`:
```{.bash code-line-numbers=false}
cat birds.txt | sort | awk '{FS=","}{print $2}' > sorted-birds.txt
```
- `awk` is a scripting language used for manipulating data and generating reports.
  - It supports variables, numeric functions, string functions, and logical operators.
  - It allows for setting field seperators of multiple characters, whereas `cut` is restricted to a single character field seperator. 
- The '`{FS=","}`' part of the `awk` command sets the field seperator to a comma, to set as a space followed by a comma use '`{FS=" ,"}`'

:::


## `head` and `tail` {.smaller}
- The `head` command prints the first lines of a file.
- The `tail` command prints the last lines of a file.
- The default number of lines is 10.
 - This can be changed with the '`-n`' option


## `head` and `tail` exercise {.smaller}

::: {.panel-tabset}

### Problem
- List all the lines in the files in `IOM-animals` directory alphabetically and find the `50th` item.

### Solution
- Use `head` to get the first 50 lines and `pipe it` to `tail` to get the last one:
```{.bash code-line-numbers=false}
sort *.txt | head -n 50 | tail -n 1
```
\
\
- Another option is to use the `sed` command instead of `head` and `tail`:
```{.bash code-line-numbers=false}
sort *.txt | sed -n 50p
```
:::


## `sed` 1/2 {.smaller}
- A program command tool for stream editing.
- `sed` reads an input stream and produces an output stream.
  - Internally it has a pattern space and a hold buffer.
  - Data is read from the input stream until the next newline character and placed into the pattern space.
  - Operations can be performed on the data in the pattern space.
  - Data can be exchanged between the pattern space and the hold buffer.
  - Once all specified operations have been performed, the pattern space is ouput and a newline characer is added at the end.


## `sed` 2/2 {.smaller}
- A simple `sed` program:
```{.bash code-line-numbers=false}
sed 's/foo/bar/'
```
- This program replaces all instance of 'foo' with 'bar' on every line.
- Beware of `sed` as it can modify files.


## `grep`
- A command to print all lines containing or not containing a string of characters.
- The following will stream out all input lines containing 'foo':
```{.bash code-line-numbers=false}
grep foo
```
- The following will stream out all input lines not containing 'foo':
```{.bash code-line-numbers=false}
grep -v foo
```

## `sed` and `grep` demo 
::: {.notes}
- Offer a demo?
:::

## data challenge exercise {.smaller}

::: {.panel-tabset}

### Problem
- `shell-training/data/` contains 300 data files, each of which should contain 100 values. One or more of these files are missing some data though...
- Use a series of commands connected by pipes to identify which files have missing data.
- Hints:
  - `wc -w` will tell you the number of values in a file
  - `sort -n` will sort numerically

### Solution
- Using `grep`:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | grep -v '100 values'
```
\
- Using `head`:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | head
```
\
\
- Alternatively `awk` could be used:
```{.bash code-line-numbers=false}
wc -w values* | sort -n | awk '$1 != 100 {print $0}'
```
:::


## Permissions 1/4 {.smaller}
- File permissions can be identified using the `ls` command with the `-l` option.
- By default, the owner has read, write and execute permissions on a directory they create, and read and write (but not execute) permission on a file they create.
- By default, group and all have no permissions.
```{.bash code-line-numbers=false}
[user@host ~]$ mkdirs -p test0/test
[user@host ~]$ touch test0/test/test-file
[user@host ~]$ ls -la test0/test
drwx------ 2 <owner> <group> <size> <date> <time> .
drwx------ 3 <owner> <group> <size> <date> <time> ..
-rw------- 1 <owner> <group> <size> <date> <time> test-file
```


## Permissions 2/4 {.smaller}
- A schematic to help explain what `ls -l` shows:
```
-rw------- 1 <owner> <group> <size> <date> <time> test-file
     |     |    |       |       |      |      |
     |     |    |       |       |      |      +----> time last modified
     |     |    |       |       |      +-----------> date last modified
     |     |    |       |       +------------------> size in bytes
     |     |    |       +--------------------------> group assignment
     |     |    +----------------------------------> owner username
     |     +---------------------------------------> number of hard link
     +---------------------------------------------> type and permissions
```
- A schematic to help explain the type and permissions part:
```
-rw-------
| |  |  |
| |  |  +----> all user permissions (3 characters)
| |  +-------> group user permissions (3 characters)
| +----------> owner permissions (3 characters)
+------------> type (1 character)
```


## Permissions 3/4 {.smaller}
### Type and permissions examples
- ```drwxr-x---```
  - type: directory
  - owner permissions: read, write and execute
  - group user permissions: read and execute
  - all user permissions: none
- ```-rw-------```
  - type: file
  - owner permissions: read and write
  - group user permissions: none
  - all user permissions: none


## Permissions 4/4 {.smaller}
- Permissions may be changed using the `chmod` command.
- Specific permissions can be granted or removed or all permissions can be specified.
- The following would set permissions ```-rwx------``` to '`test0/test/test-file`':
```{.bash code-line-numbers=false}
chmod 700 test0/test/test-file
```
- Don't worry about remembering details of how to change permissions.
- Try to remember that there are 3 levels of permission:
  - user (owner), group and all
- Try to remember that there are 3 types of permission:
  - read, write and execute

::: {.notes}
- The following would add user (owner) execute permissions.
  - So if the file already had all other permissions as wanted this would work. 
```{.bash code-line-numbers=false}
chmod u+x test0/test/test-file
```
- octal value = read (4) + write (2) + execute (1)
- Later on we will set permissions on a file to execute it.
:::


## Groups {.smaller} {visibility="hidden"}
- System users belong to groups (at least one).
- A user can change the group assignment for a file or directory to other groups they belong to using the command `chgrp`.
- The command `groups` can be used to print out what groups there are, and what group a user is part of.
- This can be useful if you want to share files between those in a group on the system.


## Check point {.smaller}
- Any questons?

::: {.notes}
- Time for a break?
:::


## Variables {.smaller}
- Variables are defined and accessed as follows:
```{.bash code-line-numbers=false}
var=1
echo $var
```
- The variable `var` is set equal to the number `1`.
- `echo` is a command that will send what comes after it to standard out
- The value of the variable is accessed using the `$` symbol followed by the name of the variable.
- The command `printenv` will print all the variables.


## For loop 1/2 {.smaller}
```
- Example for loop with iterator syntax to print the numbers 1 to 5:
```{.bash code-line-numbers=false}
for ((i=1;i<=5;i=i+1)) do echo $i; done
```
- Example for loop with sequence syntax to print the numbers 1 to 5:
```{.bash code-line-numbers=false}
for i in {1..5}; do echo $i; done
```
- Example for loop with sequence syntax to print even numbers from 2 to 10:
```{.bash code-line-numbers=false}
for i in {2..10..2}; do echo $i; done
```
- Example for loop with iterator syntax to print a geometric series from 2 to 256:
```{.bash code-line-numbers=false}
for ((i=2;i<=265;i=i*2)) do echo $i; done
```


## For loop 2/2 {.smaller}
- Example for loop to loop through directory contents:
```{.bash code-line-numbers=false}
for f in *; do echo $f; done
```
- Where there is a '`;`' there can be a new line:
```{.bash code-line-numbers=false}
for f in *
 do echo $f
 done
```


## For loops exercise 1 {.smaller}

::: {.panel-tabset}

### Problem
- Use a for loop to create five directories called `calculation_?`, where `?` is a number. 

### Solution
- For loop with an iterator syntax
```{.bash code-line-numbers=false}
for ((i=1;i<6;i++))
do
mkdir calculation_$i
done
```
- '`i++`' is shorthand for '`i=i+1`'
- For loop with a sequence syntax
```{.bash code-line-numbers=false}
for i in {1..5}
do
mkdir calculation_$i
done
```

:::


## For loops exercise 2 {.smaller}

::: {.panel-tabset}

### Problem
- Use a for loop to create five directories, each one the parent of the next.

### Solution
```{.bash code-line-numbers=false}
for i in {1..5}; do
mkdir calculation_$i
cd calculation_$i
done
```

:::


## Wildcards {.smaller}
- There are 3 types of wildcard in Linux:
  - `*` can represent anything.
  - `?` can represent any single character.
  - `[]` can represent any single characters detailed in the square brackets.
- The following will list all files starting with a:
```{.bash code-line-numbers=false}
`ls a*`
```
- The following will list all files starting with `a` and ending `.txt` that have one character between these:
```{.bash code-line-numbers=false}
`ls a?.txt`
```
- The following will list all files starting with `a` and ending `.txt` that have any other string with a `0` or a `1` character between these:
```{.bash code-line-numbers=false}
`ls a[12].txt`
```


## Wildcards exercise {.smaller}

::: {.panel-tabset}

### Problem
- Print out the first line of each file in the `wildcards` directory.

### Solution

```{.bash code-line-numbers=false}
for f in *.txt
> do
> head -n 1 $f
> done
```

:::


## quiz {.smaller}

::: {.panel-tabset}

### Questions
1. If the following is run from the wildcards directory. What will be printed?
```{.bash code-line-numbers=false}
for f in *.txt
> do
> echo $f
> cat $f > new-file.txt
> done
```
2. What will the contents of `new-file.txt` be and why?

### Answers
1.
- The command will print the name of each `.txt` file.
- On each iteration the `echo` command prints a different file name.
2.
- The content of `new-file.txt` will be the same as `xyz.txt`
- On each iteration the contents of a different file are written to `new-file.txt`, overwriting whatever was written on the previous iteration
- This is because `>` overwrites the output of cat to `new-file.txt` for each element in the sequence.
- Using `>>` instead would result in each file's content being appended to the end of `new-file.txt`

:::


## Editing files {.smaller}
- These are three programs available on the system that can be used for text editing:
  - `nano`
  - `vim`
  - `emacs`
- If you are unfamiliar with any of these, we recommend you try `nano`.
- Care is needed if transferring scripts and data between Windows and Linux due to differences in line endings.
  - `dos2unix` and `unix2dos` may be helpful to get this right.

::: {.notes}
- Data/File transfer is covered in HPC1.
:::


## Shell Scripts {.smaller}
- These are simple text files.
  - By convention the filename ends `.sh`.
- The file should start with a 'shebang' line which tells the Linux system what command to run:
```{.bash code-line-numbers=false}
#!/bin/bash
```
- After the 'shebang', simply enter all the commands for the script.
- Lines starting with '`#`' will be regarded as comments
  - Use these to make you script easier to understand.
- To run the script it must have executable permissions.
- A scripts saved as '`script.sh`' can be run using:
```{.bash code-line-numbers=false}
./script.sh
```


## Shell Scripts demo {.smaller}


## Shell Script exercise {.smaller}
- Create and run a shell script to print out the first line of each file in a directory. Test using the wildcards directory.
- Hints:
  - Use the `history` command to see the commands you executed.
  - You could pipe this into tail and direct it into a file and then use `nano` to modify this into a script.
  - Modify the file permissions so you can execute the file. 
  - To execute a script called '`script.sh`' issue the following command:
```{.bash code-line-numbers=false}
./script.sh
```

::: {.notes}
- Scripts you write that you commonly want to run can be put somehwere sensible and this can be added to your PATH.
- If there is more time, perhaps look at some other `built-in` commands.
:::


{{< include _end.qmd >}}
